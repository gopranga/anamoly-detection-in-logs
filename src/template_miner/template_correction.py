# src/template_miner/template_correction.py
"""
Provides a function to apply heuristic correction rules to log templates.
This helps normalize templates generated by automated miners like Drain3
to a more consistent and human-readable format.
"""

import re
from typing import List, Optional


def correct_oracle_template(
    template_string: str, user_strings: Optional[List[str]] = None
) -> str:
    """
    Applies a series of heuristic regex rules to correct a log template string.

    This function normalizes common variable patterns (like numbers, paths, booleans)
    and collapses redundant variable markers.

    Args:
        template_string: The raw log template generated by a miner.
        user_strings: An optional list of custom strings to treat as variables.

    Returns:
        A corrected, more standardized log template string.
    """
    if not isinstance(template_string, str):
        return ""

    corrected_template = template_string

    # Rule: Digit (DG) - standalone numbers -> "<*>"
    corrected_template = re.sub(r"\b\d+\b", "<*>", corrected_template)

    # Rule: Boolean (BL) - true/false (case-insensitive) -> "<*>"
    corrected_template = re.sub(
        r"\b(true|false)\b", "<*>", corrected_template, flags=re.IGNORECASE
    )

    # Rule: Windows Path
    win_path = r"(?<![A-Za-z0-9._-])(?:[A-Za-z]:\\(?:[^\\\s]+\\)*[^\\\s]+\\?)(?![A-Za-z0-9._-])"
    corrected_template = re.sub(win_path, "<*>", corrected_template)

    # Rule: Path String (PS) - simplified Unix-like paths -> "<*>"
    nix_path = r"(?<![A-Za-z0-9._-])(?:~?/)(?:[A-Za-z0-9._-]+/)*[A-Za-z0-9._-]+/?(?![A-Za-z0-9._-])"
    corrected_template = re.sub(nix_path, "<*>", corrected_template)

    # Rule: User-defined String (US) - treat provided strings as variables
    if user_strings:
        unique_terms = sorted({s for s in user_strings if s}, key=len, reverse=True)
        escaped_terms = [re.escape(s) for s in unique_terms]
        user_regex = r"(?<!\w)(?:" + "|".join(escaped_terms) + r")(?!\w)"
        corrected_template = re.sub(
            user_regex, "<*>", corrected_template, flags=re.IGNORECASE
        )

    # Rule: Mixed Token (MT) - tokens containing <*> -> "<*>"
    mt_seg = r'(?:(?<=^)|(?<=[\s,;:(){}\[\]"\'\']))[^ ,\s;:(){}\[\]"\'\']*<\*>[^,\s;:(){}\[\]"\'\']*(?=(?:$|[\s,;:(){}\[\]"\']))'
    corrected_template = re.sub(mt_seg, "<*>", corrected_template)

    # Rule: Dot-separated Variables (DV) - collapse "<*>.<*>" chains to "<*>"
    corrected_template = re.sub(r"(?:<\*>\s*\.\s*)+<\*>", "<*>", corrected_template)

    # Rule: Consecutive Variables (CV) - collapse "<*> <*>..." to "<*>"
    corrected_template = re.sub(r"(?:<\*>\s*)+<\*>", "<*>", corrected_template)

    # Rule: Double Spaces (DS) - collapse runs of spaces/tabs
    corrected_template = re.sub(r"[ \t]{2,}", " ", corrected_template)

    return corrected_template.strip()